# 消息收发规范文档

## 概述
本文档旨在为使用消息提供详细的开发规范和指导。通过本指南，您将了解如何使用消息组件。

## 组件说明
- 消息组件是使用消息中间件作为消息载体，进行消息通信。
- 智能引擎提供ACTIVEMQ、KAFKA、RABBITMQ、ROCKETMQ、REDIS、MQS等组件，可根据实际引入相关组件，并进行配置。
- 消息组件不得用于超过10k的对象的传递



## 引入组件包

- 用户可根据部署环境，选择以下一种消息中间件类型。不同的消息中间件类型，需要引入不同的jar包，但应用层所使用的接口是一致的


| 消息中间件  |  groupId |  artifactId | 适配版本|
| ------------ | ------------ | ------------ |------------ |
| ACTIVEMQ  | com.ygsoft.jt.teng  | teng.cp.message.activemq  | ACTIVEMQ 5.18.4 |
| KAFKA  | com.ygsoft.jt.teng  | teng.cp.message.kafka  | KAFKA 2.2.0 |
| RABBITMQ  | com.ygsoft.jt.teng  | teng.cp.message.rabbitmq  | RABBITMQ 3.8.35|
| ROCKETMQ  | com.ygsoft.jt.teng  | teng.cp.message.rocketmq  | ROCKETMQ 4.9.8|
| REDIS  | com.ygsoft.jt.teng  | teng.cp.message.redis  | REDIS 6.2.7|
| MQS  | com.ygsoft.jt.teng  | teng.cp.message.mqs  | apache-zookeeper-3.5.5 + kafka-2.2.0 |


## 创建消息扩展点
- 在resource目录建立META-INF/ecp-message/ecp.message.json文件
- 在该文件上，加上需要发送主题的信息，格式为：

```json
[
  {
    "topicId":"myqueue",     // 主题id或队列id
    "persistent":true,       // 是否持久化
    "isPub":false            // 是否主题，true为主题,  false为队列
  }
]
```


​	
## 创建消息发送对象

```java
import com.ygsoft.jt.teng.fw.core.base.model.CommonResult;
import com.ygsoft.jt.teng.fw.core.service.dcispec.EcpGetMapping;
import com.ygsoft.jt.teng.cp.message.core.sdk.annotation.EcpMsgSender;
import com.ygsoft.jt.teng.cp.message.core.sdk.service.EcpMsgSenderService;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/mq")
public class MessageProducer {
    /**
     * 消息生产者对象.
     */
    @EcpMsgSender("myqueue")
    private EcpMsgSenderService myQueueProducer;

    @ResponseBody
    @EcpGetMapping("/sendQueueMsg")
    public CommonResult<String> sendQueueMsg(final String msg) {
        final String result = "发送队列消息：我发送的内容是[" + msg + "]。";

        myQueueProducer.sendMessage(msg);

        if (LOG.isInfoEnabled()) {
            LOG.info("我发送的内容是[" + msg + "]。");
        }

        return CommonResult.of(result);
    }
}
```

```java
/**
 * @ReviewInfo(reviewer= "guoguangfu", date = "2025-01-21")
 * level 值为  1-18
 */
@ResponseBody
@EcpGetMapping("/sendDelayTopicMsg")
public CommonResult<String> sendDelayTopicMsg(final String msg,int level) {
	final String result = "发送延时主题消息：我发送的内容是[" + msg + "]。";

	myTopicProducer.sendDelayMessage(msg,level);

	if (LOG.isInfoEnabled()) {
		LOG.info(result);
	}

	return CommonResult.of(result);
}

/**
 * @ReviewInfo(reviewer= "guoguangfu", date = "2025-01-21")
 * level 值为  1-18
 */
@ResponseBody
@EcpGetMapping("/sendDelayQueueMsg")
public CommonResult<String> sendDelayQueueMsg(final String msg,final int level) {
	final String result = "发送延时队列消息：我发送的内容是[" + msg + "]。";

	myQueueProducer.sendDelayMessage(msg,level);

	if (LOG.isInfoEnabled()) {
		LOG.info("我发送的延时队列内容是[" + msg + "]。");
	}

	return CommonResult.of(result);
}
```


```
Level 1 (1秒): 消息将在1秒后被投递。
Level 2 (5秒): 消息将在5秒后被投递。
Level 3 (10秒): 消息将在10秒后被投递。
Level 4 (30秒): 消息将在30秒后被投递。
Level 5 (1分钟): 消息将在1分钟后被投递。
Level 6 (2分钟): 消息将在2分钟后被投递。
Level 7 (5分钟): 消息将在5分钟后被投递。
Level 8 (10分钟): 消息将在10分钟后被投递。
Level 9 (15分钟): 消息将在15分钟后被投递。
Level 10 (30分钟): 消息将在30分钟后被投递。
Level 11 (1小时): 消息将在1小时后被投递。
Level 12 (2小时): 消息将在2小时后被投递。
Level 13 (3小时): 消息将在3小时后被投递。
Level 14 (4小时): 消息将在4小时后被投递。
Level 15 (6小时): 消息将在6小时后被投递。
Level 16 (12小时): 消息将在12小时后被投递。
Level 17 (18小时): 消息将在18小时后被投递。
Level 18 (1天): 消息将在一天后被投递。
```



## 创建消息监听对象

- 步骤：

  ​	1、EcpMsgListener 注解监听对应的主题

  ​	2、监听类实现IEcpMsgListener接口即可

```java
import com.ygsoft.jt.teng.fw.core.log.IJtLog;
import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
import com.ygsoft.jt.teng.cp.message.core.sdk.annotation.EcpMsgListener;
import com.ygsoft.jt.teng.cp.message.core.sdk.bo.EcpMsg;
import com.ygsoft.jt.teng.cp.message.core.sdk.iface.IEcpMsgListener;

@EcpMsgListener(topics = { "myqueue" })
public class MessageQueueListener implements IEcpMsgListener {
/**
 * 日志对象.
 */
private static final IJtLog LOG = JtLogFactory.getLog(MessageQueueListener.class);

@Override
public void onMessage(final EcpMsg ecpMsg) {
	if (LOG.isInfoEnabled()) {
		LOG.info("消费队列消息，消费内容[" + ecpMsg.getMessagePayload() + "]");
		}
	}
}
```
