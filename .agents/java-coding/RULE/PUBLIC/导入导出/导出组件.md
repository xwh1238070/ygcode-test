# 导出组件规范文档

## 概述
本文档旨在为使用导出组件提供详细的开发规范和指导。通过本指南，您将了解如何使用导出组件。

导出组件


## 坐标
maven依赖：
```xml
<dependency>
	<groupId>com.ygsoft.jt.teng</groupId>
	<artifactId>teng.cp.file.export</artifactId>
	<version>${jt.version}</version>
</dependency>
```


## 导出支持自定义单元格显示格式
​	支持设置单元格显示格式的类型有：string/number/currency/date

各个单元格类型的默认格式为：

- `string`：文本格式，无任何处理

- `number`：数值格式，无任何处理

- `currency`：金额格式，默认会加上千分位，保留2位小数

- `date`：日期类型，默认会保留年月日，例：2025-06-20

设置自定义格式：
**具体格式设置如何传参，问AI，例:手机号中间有空格传`000\\ 0000\\ 0000`**

1. 同步导出：在s中设置即可
2. 异步导出：在format中设置



## 六、异步导出支持合并数据行单元格


- 后端代码示例：

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.mapp.sample.impl.component.export.service;

import com.alibaba.fastjson.JSONObject;
import com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportDataRowMergeProcess;
import org.apache.poi.ss.util.CellRangeAddress;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * 自定义数据行合并处理器.
 *
 * @version 1.0.0 JDK1.8
 * @date 2025/4/23
 * @ReviewInfo(reviewer = "hanyu2", date = "2025/4/23")
 */
@Service
public class DemoExportDataRowMergeProcess implements IExportDataRowMergeProcess {

    /**
     * 返回合并单元格对象列表.
     * @param sheetName
     * @param exportPrams
     * @return
     * @ReviewInfo(reviewer = "hanyu2", date = "2025-04-24")
     */
    @Override
    public List<CellRangeAddress> getMergedRegion(final String sheetName, final JSONObject exportPrams) {
        // 需要合并的单元格可由导出参数传进来
        final List<CellRangeAddress> mergedRegionList = new ArrayList<>();
        // 行和列从0开始
        // 表示这个单元格需要合并第2行和第3行，位于第3列
        mergedRegionList.add(new CellRangeAddress(2, 3, 3, 3));
        // 表示这个单元格位于第6行，需要合并第0列和第1列
        mergedRegionList.add(new CellRangeAddress(6, 6, 0, 1));
        return mergedRegionList;
    }

}

```



## 七、异步导出支持导出自定义文件

- 后端代码示例`实现com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportCustomFileProcess接口，注册为springBean`：

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.mapp.sample.impl.component.export.service;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportCustomFileProcess;
import com.ygsoft.jt.teng.cp.file.export.vo.ExpImpRequestVO;
import com.ygsoft.jt.teng.fw.core.log.IJtLog;
import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
import org.springframework.stereotype.Service;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

/**
 * 导出自定义文件处理器.
 *
 * @version 1.0.0 JDK1.8
 * @date 2025/4/13
 * @ReviewInfo(reviewer = "hanyu2", date = "2025/4/13")
 */
@Service
public class DemoExportCustomFileProcess implements IExportCustomFileProcess {

    /**
     * log.
     */
    private static final IJtLog LOG = JtLogFactory.getLog(DemoExportCustomFileProcess.class);

    /**
     * 导出自定义文件.<br/>
     * 导出非Excel文件等组件无法处理的文件会进入这个方法.
     * @param exportVO
     *          导出的文件名，文件类型，功能点名称等在这个VO获取.
     * @param exportPrams
     *          导出的自定义参数
     * @return
     */
    @Override
    public Map<String, byte[]> exportCustomFile(
            final ExpImpRequestVO exportVO, final JSONObject exportPrams) {

        // key是导出的文件名，value是要导出的文件
        final Map<String, byte[]> exportFileMap = new HashMap<>();
        try {
            final JSONArray fileList = exportPrams.getJSONArray("file");
            if (fileList.isEmpty()) {
                return exportFileMap;
            }

            for (int i = 0; i < fileList.size(); i++) {
                final JSONObject jsonObject = fileList.getJSONObject(i);
                final String fileName = jsonObject.getString("fileName");
                final String filePath = jsonObject.getString("filePath");
                final Path path = Paths.get(filePath);
                final byte[] bytes = Files.readAllBytes(path);
                exportFileMap.put(fileName, bytes);
            }
        } catch (Exception e) {
            if (LOG.isErrorEnabled()) {
                LOG.error("导出自定义文件出现错误：" + e.getMessage(), e);
            }
        }
        return exportFileMap;
    }
}

```



## 八、导出模板支持导出自定义Excel文件

- ​	后端实现接口：`com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportTemplateProcessor`，并注册为springBean。

- ​	在导出模板时，程序会自动调用`boolean isCustomTemplate(ExpImpRequestVO paramVO)`方法，返回是否需要自定义模板；如果返回true，则继续调用`byte[] getExportTemplate(ExpImpRequestVO paramVO)`返回模板文件的字节数组，并在浏览器下载。

- 使用示例：

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.mapp.sample.impl.component.export.service;

import com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportTemplateProcessor;
import com.ygsoft.jt.teng.cp.file.export.vo.ExpImpRequestVO;
import com.ygsoft.jt.teng.fw.core.log.IJtLog;
import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
import org.apache.commons.io.IOUtils;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;

import java.io.InputStream;

/**
 * 自定义导出模板处理器.
 *
 * @version 1.0.0 JDK1.8
 * @date 2025/3/19
 * @ReviewInfo(reviewer = "hanyu2", date = "2025/3/19")
 */
@Component
public class DemoExportTemplateProcessor implements IExportTemplateProcessor {

    /**
     * log.
     */
    private static final IJtLog LOG = JtLogFactory.getLog(DemoExportTemplateProcessor.class);

    /**
     * 本次导出是否需要自定义模板.
     * @param paramVO
     * @return
     * @ReviewInfo(reviewer = "hanyu2", date = "2025-03-20")
     */
    @Override
    public boolean isCustomTemplate(final ExpImpRequestVO paramVO) {
        // 确定导出模板的场景，比如导出文件名是（导出测试-非结构化）时，需要自定义模板
        if ("导出测试-非结构化".equals(paramVO.getFileName())) {
            return true;
        }
        return false;
    }


    /**
     * 返回模板文件的字节数组.
     * @param paramVO
     * @return
     * @ReviewInfo(reviewer = "hanyu2", date = "2025-03-20")
     */
    @Override
    public byte[] getExportTemplate(ExpImpRequestVO paramVO) {
        // 根据导出模板场景，返回不同的自定义模板文件
        // 取resources目录下的文件
        final String filePath = "exportTemplate/导出测试-导出模板.log.xlsx";
        final Resource resource = new ClassPathResource(filePath);
        try (InputStream in = resource.getInputStream();) {
            return IOUtils.toByteArray(in);
        } catch (Exception e) {
            if (LOG.isErrorEnabled()) {
                LOG.error("获取自定义模板出错：" + e.getMessage(), e);
            }
            throw new RuntimeException(e);
        }
    }
}

```



## 九、导出组件新增工具方法，将Workbook对象的数据写到流中

​	方法名：`com.ygsoft.jt.teng.cp.file.export.util.release.JtExportReleaseUtil#writeWorkbook`
```java
/**
* 封装workbook的write方法.<br/>
* 由调用方自行维护输出流以及关闭workbook对象.
* @param workbook
* @param outputStream
* @return 操作结果
* @ReviewInfo(reviewer = "hanyu2", date = "2025-03-18")
*/
public static boolean writeWorkbook(final Workbook workbook, final OutputStream outputStream)
```



## 十、导出模板支持表头设置富文本，如*单独设置为红色

- ​	组件默认只会将*设置为红色，业务组只需要将单元格的dt设置为richText

- ​	如果业务组有额外设置要求，可实现扩展接口：`com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportRichTextProcessor`自行处理

- 代码示例：

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.mapp.sample.impl.component.export.service;

import com.alibaba.fastjson.JSONObject;
import com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IExportRichTextProcessor;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.RichTextString;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * 导出富文本扩展处理类样例.
 *
 * @version 1.0.0 JDK1.8
 * @date 2025/2/27
 * @ReviewInfo(reviewer = "hanyu2", date = "2025/2/27")
 */
@Component
public class DemoExportRichTextProcessor implements IExportRichTextProcessor {

    /**
     * 处理富文本字体.
     * 此样例方法是把#设置为黄色.
     * @param richText  富文本对象
     * @param richTextFont  富文本字体
     * @param cellData  单元格内容json对象
     * @ReviewInfo(reviewer = "hanyu2", date = "2025-02-28")
     */
    @Override
    public void processRichText(
            final RichTextString richText, final Font richTextFont, final JSONObject cellData) {
        final String text = cellData.getString("d");
        // 将#设置为黄色
        if (text.contains("#")) {
            final List<Integer> charIndexList = new ArrayList<>();
            // 找到*所在位置
            for (int i = 0; i < text.length(); i++) {
                final char c = text.charAt(i);
                if ('#' == c) {
                    charIndexList.add(i);
                }
            }
            richTextFont.setColor(IndexedColors.YELLOW.getIndex());
            // 设置#为特殊字体
            for (int index : charIndexList) {
                richText.applyFont(index, index + 1, richTextFont);
            }
        }
    }
}

```



## 十一、导出支持管理对象等自动id名称转换

​	用法：在colModel里，将列的dataType设置为可自动进行id名称转换的类型，如gldx；组件会自动调用中台已有的id名称转换方法将转换好的名称赋值到该列。

- 系统内置可自动id名称转换的类型有：

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.teng.cp.file.export.enums;

/**
 * 需要进行id名称转换类型的枚举.
 *
 * @version 1.0.0 JDK1.8
 * @date 2025/1/20
 * @ReviewInfo(reviewer = "hanyu2", date = "2025/1/20")
 */
public enum JtExportIdToNameTypeEnum {

    /**
     * 审计项.
     */
    ECP_AUDIT_ITEM("ECP.AUDITITEM"),

    /**
     * ECP基础模型.
     */
    ECP_APP_BASE("ECP.APP.BASE"),

    /**
     * 数据类型ID名称转换器.
     */
    DATA_TYPE("DATATYPE"),

    /**
     *数据中心ID转名称适配器.
     */
    DATACENTER("DATACENTER"),

    /**
     *通用实体类别ID名称转换.
     */
    ECP_CLASS("ECP.CLASS"),

    /**
     * 单位ID转名称适配器.
     */
    ORGANISE("ORGANISE"),

    /**
     *通用实体类型ID名称转换.
     */
    ECP_ENTITYTYPE("ECP.ENTITYTYPE"),

    /**
     *通用实体类型ID名称转换.
     */
    ECP_REFTYPE_ECP_ENTITY("ECP.REFTYPE.ECP.ENTITY"),

    /**
     *管理对象ID名称转换器.
     */
    ENUM("ENUM"),

    /**
     *管理对象ID名称转换器.
     */
    ECP_REFTYPE_ENUM("ECP.REFTYPE.ENUM"),

    /**
     *汇率方案ID转名称适配器.
     */
    EXCHANGESCHEME("EXCHANGESCHEME"),

    /**
     *通用实体ID名称转换.
     */
    ECP_ENTITY("ECP.ENTITY"),

    /**
     *管理业务类型ID转名称适配器.
     */
    ECP_REFTYPE_JCGLYWLX("ECP.REFTYPE.JCGLYWLX"),

    /**
     * 科目ID名称转换器.
     */
    ECP_REFTYPE_KM("ECP.REFTYPE.KM"),

    /**
     *分层ID名称转换.
     */
    ECP_REFTYPE_layer("ECP.REFTYPE.layer"),

    /**
     *多语言ID名称转换器.
     */
    LOCALESTRING("LOCALESTRING"),

    /**
     *锁定组织IDMC转换类.
     */
    LOCKORGTRANS("LOCKORGTRANS"),

    /**
     *单位ID转名称适配器.
     */
    MULTIORG("MULTIORG"),

    /**
     *币种ID转名称适配器.
     */
    NEWCURRENCY("NEWCURRENCY"),

    /**
     *组织类型ID转名称适配器.
     */
    organiseType("organiseType"),

    /**
     *查询主题显示名称转换器.
     */
    querytopic("querytopic"),

    /**
     *RegionEntitySelectorTranslator.
     */
    REGION("REGION"),

    /**
     *汇报关系转换器.
     */
    VO_REPORTRELATION("VO.REPORTRELATION"),

    /**
     *系统枚举名称转换.
     */
    SYSENUM("SYSENUM"),

    /**
     *通用表ID名称转换.
     */
    ECP_TABLEENTITY("ECP.TABLEENTITY"),

    /**
     *系统单位ID名称转换器.
     */
    UNITCODE("UNITCODE"),

    /**
     *币种ID转名称适配器.
     */
    XTMONEY("XTMONEY"),

    /**
     *业务单据类型ID名称转换器.
     */
    ECP_REFTYPE_GRIS_YWDJ("ECP.REFTYPE.GRIS.YWDJ"),

    /**
     *对象分类ID名称转换器.
     */
    ECP_REFTYPE_YWFL("ECP.REFTYPE.YWFL"),

    /**
     * 管理对象.
     */
    GLDX("gldx"),

    /**
     * 对象分类.
     */
    DXFL("dxfl"),

    /**
     *用于对象分类IID和CAPTION之间的名称转换.
     */
    ECP_REFTYPE_DXFL("ECP.REFTYPE.DXFL"),

    /**
     * 业务分类.
     */
    YWFL("ywfl")
    ;

    /**
     * 文件扩展名.
     */
    private String fileType;

    /**
     * 构造函数.
     * @param fileType
     * @ReviewInfo(reviewer = "hanyu2", date = "2025-01-20")
     */
    JtExportIdToNameTypeEnum(final String fileType) {
        this.fileType = fileType;
    }
    
    /**
     * get fileType.
     */
    public String getFileType() {
        return fileType;
    }

    /**
     * set fileType.
     */
    public void setFileType(String fileType) {
        this.fileType = fileType;
    }
}

```



## 十二、导出支持自定义日期和金额的单元格显示格式

### 1.异步导出

#### 1）日期类型设置显示格式

- 将dataType设置为date

- format字段按需设置，未设置情况下显示年月日，如2025-02-11

- format字段设置示例（示例未出现的格式自行问AI）：

##### a、设置为 yyyy-mm-dd HH:mm:ss

##### b、设置为[DBNum1][$-804]yyyy年m月d日

#### 2）导出金额设置显示格式

- 将dataType设置为currency

- format字段按需设置，未设置情况下显示格式为阿拉伯数字，并会带上千分位和2位小数
  例：12,321.00

- format字段设置示例（示例未出现的格式自行问AI）：
  设置为#,##0.00，效果是给金额加上千分位和2位小数，与默认不设置时一致

##### a、设置为[DBNum1]

##### b、设置为[DBNum2]

##### c、设置为[DBNum2]General元整



## 十三、导出支持自适应列宽，与前端列宽保持一致
​	使用方式：调用qzz表格方法获取表头，将会自动带上列宽属性传入导出组件中



## 十四、异步导出支持导出CSV格式
​	*备注： 此功能组件自动适配，无需业务组修改代码，只需重新编译构建更新前后端服务即可*




##  十五、异步导出支持打包额外附件
- 文档地址：[wcp文档地址](http://10.51.150.178:8989/webdoc/real/Pub8ab316328cc95524018e74ba51600bc9.html?STATE=0&OPERATE=3)

- 实现效果：导出的文件会打包为ZIP，里面包含其他附件

- 使用方式：

  1、新建类，实现`com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IJtExportAttachmentService`接口，并注册为springBean。

  2、实现`getAttachmentMap`方法，返回附件路径和附件的File对象

  3、扩展用法
  `IJtExportAttachmentService`接口提供了2个可重写的方法，`isAddAttachment`和`finishPackageAttachment`

    - `isAddAttachment`方法：本次导出是否需要打包附件，入参fromFunName为导出功能点名称、fileName为本次导出的文件名，
      这两个都是业务组使用导出组件时必须传入的参数。返回true说明本次导出需要打包附件，组件会调用getAttachmentMap方法获取附件，与导出的Excel一起打包到ZIP中。
    - `finishPackageAttachment`方法：打包完毕事件。组件在打包完附件后会调用此方法，如果业务组的附件是一次性的，可以在这个方法把临时文件删除。

- 实现类示例：
```java
	/*
	 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
	 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
	 */
	package com.ygsoft.jt.mapp.sample.impl.component.export.service;

	import com.ygsoft.jt.teng.cp.file.export.interfaces.extension.IJtExportAttachmentService;
	import com.ygsoft.jt.teng.fw.core.base.util.CollectionUtil;
	import com.ygsoft.jt.teng.fw.core.base.util.StringUtil;
	import com.ygsoft.jt.teng.fw.core.log.IJtLog;
	import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
	import org.springframework.stereotype.Component;

	import java.io.File;
	import java.io.FileOutputStream;
	import java.text.MessageFormat;
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;

	/**
	 * 导出打包额外附件样例.
	 *
	 * @version 1.0.0 JDK1.8
	 * @date 2024/11/14
	 * @ReviewInfo(reviewer = "hanyu2", date = "2024/11/14")
	 */
	@Component
	public class DemoExportAttachmentService implements IJtExportAttachmentService {

		/**
		 * 日志.
		 */
		private static IJtLog LOG = JtLogFactory.getLog(DemoExportAttachmentService.class);

		/**
		 * 样例附件列表.
		 */
		private List<File> attachmentList = new ArrayList<>();

		/**
		 * 构造方法.
		 * 生成默认的附件.
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-11-14")
		 */
		public DemoExportAttachmentService() {
			final File attachmentTxt = new File("测试附件.txt");
			final File attachmentLog = new File("测试附件.log");
			try (FileOutputStream outTxt = new FileOutputStream(attachmentTxt);
				 FileOutputStream outLog = new FileOutputStream(attachmentLog)) {
				outTxt.write("这是一个测试TXT文件".getBytes());
				outLog.write("这是一个测试Log文件".getBytes());
				attachmentList.add(attachmentTxt);
				attachmentList.add(attachmentLog);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		/**
		 * 是否需要打包附件.
		 * @param fromFunName
		 * @param fileName
		 * @return
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-11-14")
		 */
		@Override
		public boolean isAddAttachment(final String fromFunName, final String fileName) {
			if (StringUtil.isNotEmpty(fromFunName) && "异步导出打包额外附件".equals(fromFunName)) {
				return true;
			}
			return false;
		}

		/**
		 * 附件map，key为zip包中文件的路径和文件名，value为实际的文件对象.
		 * @param fromFunName
		 * @param fileName
		 * @return Map
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-11-14")
		 */
		public Map<String, File> getAttachmentMap(String fromFunName, String fileName) {
			final Map<String, File> attachmentMap = new HashMap<>();
			final File attachmentTxt = attachmentList.get(0);
			final File attachmentLog = attachmentList.get(1);
			attachmentMap.put("附件描述/问题描述.txt", attachmentTxt);
			attachmentMap.put("附件日志/问题描述.txt", attachmentLog);
			return attachmentMap;
		}

		/**
		 * 覆盖默认的打包完毕方法.
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-11-14")
		 */
		@Override
		public void finishPackageAttachment(List<File> attachmentList) {
			if (LOG.isInfoEnabled() && CollectionUtil.isNotEmpty(attachmentList)) {
				StringBuilder stringBuilder = new StringBuilder();
				for (File file : attachmentList) {
					stringBuilder.append(file.getName() + ",");
				}
				LOG.info(MessageFormat.format("附件{0}打包完毕。", stringBuilder.toString()));
			}
		}
	}
```



## 十七、异步导出支持指定主从策略

- 使用方式：
	- sql在主库执行：无需改动
	- sql在从库执行：在vipaddress同一层加上dataAction: 'read0'
	```json
	dataAction: 'read0', // 指定主从策略，edit或者不配置表示主库，read0表示从库
	```
	
	

##  十八、异步导出支持按范围导出


##  十九、导出组件支持导出PDF
- 使用方式：后端引入导出组件依赖

  

## 二十、异步导出去掉20条限制逻辑

- 概述：异步导出管理页去掉只能同时存在20条导出记录限制，并且导出的文件只存放24小时，超过24小时的文件会被自动清理。
- 使用方式：业务组无需改动

  

## 二十一、导出组件支持导出合计行

- 使用方式：参考wcp文档[http://10.51.150.178:8989/webdoc/real/Pub8ab316328cc95524018e74ba51600bc9.html?STATE=0&OPERATE=3](http://10.51.150.178:8989/webdoc/real/Pub8ab316328cc95524018e74ba51600bc9.html?STATE=0&OPERATE=3)

- 代码示例：
组件提供2种合计方式：
    1、组件自动生成公式进行合计：将合计单元格的dt（数据类型）设置为function（函数），d（数据值）设置为SUM（求和函数）
	```json
	{d:'SUM',s: 'h|c',dt:'function'}
	```
	​	精度和千分位设置：精度参数scale，千分位设置map:{isThousand:true}
	```json
	{d:'SUM',s: 'h|c',dt:'function', scale:3, map:{isThousand:true}}
	```
  
	
	2、业务组计算好合计值后传给组件：业务组计算好合计值后按正常单元格方式传递即可
	
	```json
	{d:123456.78,s: 'h|c',dt:'number'}
	```
	​	精度和千分位设置：精度由业务组传入的值确定。若要添加千分位，把dt设置为currency即可。
	



## 二十二、R00069979 异步导出进度条显示

- 使用方式：后端引入导出组件依赖，打开导出管理界面后，能看到当前导出任务的进度，无需业务组进行任何修改。

  

## 二十三、R00060736异步下载管理不显示已清理数据
- 使用方式：后端引入导出组件依赖，导出管理界面点击清理后，会删除导出记录

  


## 二十四、异步下载支持批量清理


## 二十五、导出组件支持自定义单元格样式

- 使用方法：
后端java代码改动即可：业务组新建java类，实现`IJtExcelStyleService`接口，并注册为springBean，实现`setCellStyle`方法。
- 代码示例：
	```java
	/*
	 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
	 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
	 */
	package com.ygsoft.jt.mapp.sample.impl.component.export.service;

	import com.alibaba.fastjson.JSONObject;
	import com.ygsoft.jt.teng.cp.file.export.enums.ExportDataType;
	import com.ygsoft.jt.teng.cp.file.export.interfaces.IJtExcelStyleService;
	import com.ygsoft.jt.teng.fw.core.log.IJtLog;
	import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
	import org.apache.poi.hssf.util.HSSFColor;
	import org.apache.poi.ss.usermodel.CellStyle;
	import org.apache.poi.ss.usermodel.FillPatternType;
	import org.apache.poi.xssf.usermodel.XSSFCellStyle;
	import org.apache.poi.xssf.usermodel.XSSFColor;
	import org.apache.poi.xssf.usermodel.XSSFFont;
	import org.springframework.stereotype.Component;

	/**
	*  自定义导出样式样例.
	* @date 2024年6月19日 下午9:48:19
	* @version 1.0.0 JDK1.8
	* @ReviewInfo(reviewer = "hanyu2", date = "2024-06-19")
	*/
	@Component
	public class DemoExportStyleService implements IJtExcelStyleService {

		/**
		 * 日志.
		 */
		private static final IJtLog LOG = JtLogFactory.getLog(DemoExportStyleService.class);

		/**
		 * 模拟环境参数，0-公司内部，1-客户环境;
		 */
		private int envCode = 0;

		/**
		 * 自定义设置单元格样式.
		 * @param originalStyle
		 *            样式对象，修改此对象即可
		 * @param rowNum
		 *            单元格所在行
		 * @param colNum
		 *            单元格所在列号
		 * @param rowType
		 *            单元格类型，表头还是正文.
		 * @param cellData
		 *            单元格数据
		 */
		@Override
		public void setCellStyle(CellStyle originalStyle, int rowNum, int colNum, ExportDataType rowType,
				JSONObject cellData) {
			if (this.envCode != 1) {
				return;
			}

			if (originalStyle instanceof XSSFCellStyle) {
				XSSFCellStyle xssfCellStyle = (XSSFCellStyle) originalStyle;

				XSSFFont font = xssfCellStyle.getFont();
				// 赋予统一样式为微软雅黑,12号
				font.setFontName("微软雅黑");
				font.setFontHeightInPoints((short)12);

				// 表头额外设置为14号字体，白色，单元格底色#2F75B5
				if (rowType == ExportDataType.HEADER_ROW) {
					font.setFontHeightInPoints((short)14);
					font.setColor(HSSFColor.HSSFColorPredefined.WHITE.getIndex());
					xssfCellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
					// 设置单元格的背景颜色为 #2F75B5
					byte[] rgb = new byte[]{47, 117, (byte) 181};
					XSSFColor color = new XSSFColor(rgb, null);
					xssfCellStyle.setFillForegroundColor(color);
				}
				xssfCellStyle.setFont(font);
			} else {
				if (LOG.isWarnEnabled()) {
					LOG.warn("此单元格类型不支持自定义样式 ： " + originalStyle.getClass());
				}
			}
		}

		/**
		 * 切换环境.
		 * @param envCode 环境参数值
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-06-20")
		 */
		public void changeEnv(final int envCode) {
			this.envCode = envCode;
		}

	}
	```



## 二十六、导入导出对CPU内存占用控制

​	导出导入开启cpu和内存占用校验开关:`teng.cp.ixport.rescontrol.enable=true`
​	开启后，后端导出时CPU、内存使用量超过70%，内存空闲小于500M时，不允许导出。

- 使用方法：新建java类，实现`com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IImportCPUMemoryContorl`接口实现对导入的CPU内存控制
实现`com.ygsoft.jt.teng.cp.file.export.interfaces.IExportCPUMemoryContorl`接口实现对导出的CPU内存控制
- 使用代码示例：
  - 导入示例：
```java
	/*
	 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
	 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
	 */
	package com.ygsoft.jt.mapp.sample.impl.component.importer.service;

	import org.springframework.stereotype.Component;

	import com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IImportCPUMemoryContorl;
	import com.ygsoft.jt.teng.fw.core.base.cons.ServerProps;

	/**
	*  导入CPU内存控制样例类.
	* @date 2024年5月20日 上午9:52:16
	* @version 1.0.0 JDK1.8
	* @ReviewInfo(reviewer = "hanyu2", date = "2024-05-20")
	*/
	@Component
	public class DemoImportCMControlService implements IImportCPUMemoryContorl {

		/**
		 * 获取配置的cpu使用率阈值.
		 */
		private static final String CPU_USAGE = ServerProps.getProperty("jt.mapp.import.control.cpu.usage", "70");

		/**
		 * 获取配置的内存使用率阈值.
		 */
		private static final String MEMORY_USAGE = ServerProps.getProperty("jt.mapp.import.control.memory.usage", "70");

		/**
		 * 获取配置的内存余量阈值.
		 */
		private static final String MEMORY_FREE = ServerProps.getProperty("jt.mapp.import.control.memory.free", "500");

		/**
		 * 返回业务组预期的cpu使用率阈值-单位百分比，实际超过阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getCPUUsage() {
			Double cpuUsage = Double.valueOf(CPU_USAGE);
			return cpuUsage;
		};

		/**
		 * 返回业务组预期的内存使用阈值-单位百分比，实际超过阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getMemoryUsage() {
			Double memoryUsage = Double.valueOf(MEMORY_USAGE);
			return memoryUsage;
		};

		/**
		 * 返回业务组预期的内存余量阈值-单位MB，实际低于阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getMemoryFreeMB() {
			Double memoryFree = Double.valueOf(MEMORY_FREE);
			return memoryFree;
		};

	}
```




- 使用代码示例：
  - 导出示例：

```java
	/*
	 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
	 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
	 */
	package com.ygsoft.jt.mapp.sample.impl.component.export.service;

	import org.springframework.stereotype.Component;

	import com.ygsoft.jt.teng.cp.file.export.interfaces.IExportCPUMemoryContorl;
	import com.ygsoft.jt.teng.fw.core.base.cons.ServerProps;

	/**
	*  导出CPU内存控制样例类.
	* @date 2024年5月20日 上午9:30:47
	* @version 1.0.0 JDK1.8
	* @ReviewInfo(reviewer = "hanyu2", date = "2024-05-20")
	*/
	@Component
	public class DemoExportCMControlService implements IExportCPUMemoryContorl {

		/**
		 * 获取配置的cpu使用率阈值.
		 */
		private static final String CPU_USAGE = ServerProps.getProperty("jt.mapp.export.control.cpu.usage", "70");

		/**
		 * 获取配置的内存使用率阈值.
		 */
		private static final String MEMORY_USAGE = ServerProps.getProperty("jt.mapp.export.control.memory.usage", "70");

		/**
		 * 获取配置的内存余量阈值.
		 */
		private static final String MEMORY_FREE = ServerProps.getProperty("jt.mapp.export.control.memory.free", "500");

		/**
		 * 返回业务组预期的cpu使用率阈值-单位百分比，实际超过阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getCPUUsage() {
			Double cpuUsage = Double.valueOf(CPU_USAGE);
			return cpuUsage;
		};

		/**
		 * 返回业务组预期的内存使用阈值-单位百分比，实际超过阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getMemoryUsage() {
			Double memoryUsage = Double.valueOf(MEMORY_USAGE);
			return memoryUsage;
		};

		/**
		 * 返回业务组预期的内存余量阈值-单位MB，实际低于阈值后，不进行导出.
		 * @return double
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-05-18")
		 */
		public double getMemoryFreeMB() {
			Double memoryFree = Double.valueOf(MEMORY_FREE);
			return memoryFree;
		};

	}
```



## 二十七、导入导出支持对文件自定义加解密


- 使用方法：新建java类，实现com.ygsoft.jt.teng.cp.file.export.interfaces.IExportExcelEncrypt和com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IJtImportDecrypt接口，并注册为springBean

- 使用代码示例：
	```java
	/*
	 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
	 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
	 */
	package com.ygsoft.jt.mapp.sample.impl.component.export.service;

	import java.io.BufferedInputStream;
	import java.io.BufferedOutputStream;
	import java.io.File;
	import java.io.FileInputStream;
	import java.io.FileOutputStream;

	import org.springframework.stereotype.Component;

	import com.ygsoft.jt.teng.cp.file.export.interfaces.IExportExcelEncrypt;
	import com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IJtImportDecrypt;
	import com.ygsoft.jt.teng.fw.core.log.IJtLog;
	import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;

	/**
	 * 导出组件对文件加密样例类.
	 *
	 * @date 2024年4月8日 下午9:07:40
	 * @version 1.0.0 JDK1.8
	 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-08")
	 */
	@Component
	public class DemoEncryptDecryptService implements IExportExcelEncrypt, IJtImportDecrypt {

		/**
		 * 日志.
		 */
		private static IJtLog LOG = JtLogFactory.getLog(DemoEncryptDecryptService.class);

		/**
		 * 判断是否需要加密.<br>
		 *
		 * @param fileName
		 *            前端传过来的文件名.后缀
		 * @return boolean
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-08")
		 */
		public boolean isNeedEncrypt(final String fileName) {
			if (fileName.contains("加密导出")) {
				return true;
			}
			return false;
		}

		/*
		 * 加密文件.
		 * 把文件加密.
		 * 调用方法后，encryptionFilePath应该是一个加密文件.
		 * @see
		 * com.ygsoft.jt.teng.cp.file.export.interfaces.IExportExcelEncrypt#encryptFile(
		 * java.lang.String, java.lang.String)
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-08")
		 */
		@Override
		public boolean encryptFile(String sourceFilePath, String encryptionFilePath) {
			File sourceFile = new File(sourceFilePath);
			File encryptionFile = new File(encryptionFilePath);
			// 简单加密算法，把字节的每一位进行反转
			try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(sourceFile));
					BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(encryptionFile));) {
				byte[] buffer = new byte[4096];
				int bytesRead;
				while ((bytesRead = in.read(buffer)) != -1) {
					byte[] reverseByteArray = reverseByteArray(buffer);
					out.write(reverseByteArray, 0, bytesRead);
				}
			} catch (Exception e) {
				if (LOG.isErrorEnabled()) {
					LOG.error("加密文件出错", e);
				}
			}

			return true;
		}

		/**
		 * 将字节数组进行异或取值，把0->1,1-0。
		 * @param byteArray
		 * @return byte[]
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-11")
		 */
		private byte[] reverseByteArray(final byte[] byteArray) {
			byte[] encryptByteArray = new byte[byteArray.length];
			for (int i = 0; i < byteArray.length; i++) {
				encryptByteArray[i] = (byte) (byteArray[i] ^ 0xFF);
			}
			return encryptByteArray;
		}

		/*
		 * 通过文件名获取解密之后的扩展名.
		 * @see com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IJtImportDecrypt#getDecryptFileExt(java.lang.String)
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-11")
		 */
		@Override
		public String getDecryptFileExt(String encryptFileName) {
			String ext = encryptFileName.substring(encryptFileName.lastIndexOf(".") + 1);
			if ("ygsoft".equalsIgnoreCase(ext)) {
				return "xlsx";
			}
			return "xls";
		}

		/*
		 * 文件是否需要解密.
		 * @see com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IJtImportDecrypt#isNeedDecrypt(java.lang.String)
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-11")
		 */
		@Override
		public boolean isNeedDecrypt(String fileName) {
			String ext = fileName.substring(fileName.lastIndexOf(".") + 1);
			if ("ygsoft".equalsIgnoreCase(ext)) {
				return true;
			}
			return false;
		}

		/* 解密文件.
		 * @see com.ygsoft.jt.teng.cp.file.importer.component.importcomp.context.IJtImportDecrypt#decryptFile(java.lang.String, java.lang.String)
		 * @ReviewInfo(reviewer = "hanyu2", date = "2024-04-11")
		 */
		@Override
		public boolean decryptFile(String encryptionFilePath, String decryptionFilePath) {
			// TODO Auto-generated method stub
			File encryptionFile = new File(encryptionFilePath);
			File decryptionFile = new File(decryptionFilePath);
			// 简单解密算法，把字节的每一位进行反转
			try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(encryptionFile));
					BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(decryptionFile));) {
				byte[] buffer = new byte[4096];
				int bytesRead;
				while ((bytesRead = in.read(buffer)) != -1) {
					byte[] reverseByteArray = reverseByteArray(buffer);
					out.write(reverseByteArray, 0, bytesRead);
				}
			} catch (Exception e) {
				if (LOG.isErrorEnabled()) {
					LOG.error("解密文件出错", e);
				}
			}
			return true;
		}
	}
	```
	
	
	
- 扩展功能：组件默认把加密过后文件的文件名后缀改为.ygsoft。可在实现类中重写com.ygsoft.jt.teng.cp.file.export.interfaces.IExportExcelEncrypt.getEncryptFileExt()方法，自定义加密文件扩展名
	
	- 示例：
	```java
		/**
		* 获取加密文件默认扩展名.
		* 业务组可重写此方法，自由返回加密文件文件扩展名.
		* @return String
		* @ReviewInfo(reviewer = "hanyu2", date = "2024-04-08")
		*/
		public String getEncryptFileExt() {
		return "data";
		}
	```



## 三十、导出带水印文件

​	由于导出组件领导要求瘦身，删除了内置的字体文件，使用中文水印时可能出现乱码问题；
出现乱码时，可在调度中心将字体文件jt_export_font上传到固化文件列表；
 在业务服务启动时会将`jt_export_font`字体文件从固化文件下载到到部署路径的`.../export-font`目录下

- 使用示例：
调用export/single接口时，在body参数上额外加上水印相关参数`watermark`即可；
示例：
接口`/{vipAddress}/ecp/exportSerivce/export/single`
```json
{
    "fileName": "export.demo",
    "content": {
        "chooseType": true,
        "showExportFormat": false,
        "type": "xlsx",
        "watermark":{
            "text":["hy2","15797822222"], //必填；水印文本列表，一个元素代表水印一行
            "color":"#515151FF", //可选；水印的颜色和透明度，默认为浅灰色不透明#D7D7D7FF；格式：#RRGGBBAA， R:红色强度，G:绿色强度，B:蓝色强度，A:透明度00-FF完全透明-完全不透明
            "rotationAngle":-30 //可选；水印的旋转角度，正数为顺时针，负数为逆时针；默认为顺时针45度45；
        },
        "vipAddress": "/jt/mapp/sample",
        "sheets": [xxxx，省略],
        "single": false,
        "exportValidation": false
    },
    "fileType": "xlsx",
    "isTmpFile": true,
    "beanId": "com.ygsoft.necp.component.export.interfaces.IExportContext",
    "methodName": "createWookbookByParamFile(contentPath,userId,progressKey)",
    "contentType": "text",
    "sno": "-1",
    "path": "",
    "params": {
        "userId": null,
        "progressKey": null
    }
}
```






## 三十一、 异步导出

【*注意：使用异步导出功能需要在配置文件中加上`jt.cloud.ds.exception.enabled=false`；否则超过20W数据时数据访问层程序会有异常抛出，无法导出；jdbc连接需要加一个参数： `useCursorFetch=true`，表示开启游标；不加的话，在同时进行大数据量导出时，可能会出现内存溢出问题 ；*】

###  31.1 异步流式导出处理逻辑
​	1）导出组件调用业务侧before。

​	2）业务侧before接口准备导出数据转换所需要的全部基础数据并在业务侧进行缓存，返回取数sql语句。

​	3）导出组件根据取数sql语句获取游标并从游标中分批取出原始数据传递给业务侧translate接口进行导出数据转换，把数据库原始数据转换为导出数据返回给组件。

​	4）导出组件分批写入导出数据到Excel中， 当单个Excel中导出数据超过阀值时（xls为6.5万行，xlsx为10万行），导出组件将新创建一个Excel文件继续导出。生成的多个Excel文件会形成一个压缩包提供给用户下载。

​	5）导出组件释放全部基础数据、游标和线程变量。



### 31.2 自定义业务侧导出后端接口

#### 31.2.1 定义before导出接口

- 处理逻辑：准备translate接口需要的全部基础数据在业务侧进行缓存，返回取数sql语句。

- 执行次数：此接口只会执行一次。

- 参  数 值：exportContext对应的是前端params传递过来的参数值。

- 返  回 值：`CommonResult<Map<String,Object>>`，map中包含有以"sql"为key的sql语句，如sql语句有参数，也包含有以"param"为key的sql参数数组。

- 是否必须：必须定义，导出组件依赖返回的sql获取游标。 



#### 31.2.2 定义translate导出接口

- 处理逻辑：游标分批取出的原始数据在此接口进行业务逻辑处理，从Map集合参数中获取key为dataList的每批次数据库原始数据，对此每批次原始数据进行业务逻辑处理。

- 执行次数：此接口会执行【总记录数/100】次。

- 参 数  值：`exportContext`对应的是前端`params`传递过来的参数值及后端取出的每批次数据库原始数据。

- 返 回  值：`CommonResult<List<Map<String,Object>>>`，转换后的导出数据列表。

- 是否必须：可选定义，通过游标取出的数据可以满足Excel导出需求，不用做转换，则不需要定义。    



#### 31.2.3 定义after导出接口

- 处理逻辑：释放before接口所准备并缓存的全部基础数据。

- 执行次数：此接口只会执行一次。

- 参  数 值：`exportContex`t对应的是前端`params`传递过来的参数值。

- 返  回 值：`CommonResult<String>`

- 是否必须：可选定义，如果在业务侧没有本次导出相关的资源需要被释放，则不需要定义。

```java
前端配置：
after : "/jt/mapp/sample/export/after"
后端配置：
@EcpPostMapping("/after")
public CommonResult<String> after() {
    return CommonResult.of("sql");
}
```



### 31.4 异步导出后端相关接口

#### 31.4.1 异步导出
http://ip+port/{vipaddress}/ecp/exportSerivce/export/single
#### 31.4.2 下载excel文件
http://ip+port/{vipaddress}/ecp/exportSerivce/export/asyncDownLoad?ecp.mapp=true&gid=xxx
#### 31.4.3 异步导出任务查询
http://ip+port/{vipaddress}/ecp/exportSerivce/export/findTasks?ecp.mapp=true&pageNo=0&pageSize=10
#### 31.4.4 异步导出任务清理
http://ip+port/{vipaddress}/ecp/exportSerivce/export/cleanTasks?ecp.mapp=true&gids=xxx



### 31.5 后端URL导出

- 后端代码
```java
后端取数剧接口示例：
@EcpPostMapping("/where")
public CommonResult<List<Map<String, Object>>> getData(@RequestBody final Map<String, Object> exportContext){
	System.out.println(JSON.toJSONString(exportContext));
	// 构造数据
	List<Map<String, Object>> list = new ArrayList<Map<String,Object>>();
	for (int i=0; i < 12; i++) {
		// map中的key要与前端参数colModel中的name对应，并且使用大写
		Map<String, Object> data = new HashMap<>();
		data.put("BIZ_DOMAIN", "业务领域" + i);
		data.put("CLAZZ_NAME", "类名称" + i);
		data.put("CRE_TIME", "创建时间" + i);
		list.add(data);
	}
	return CommonResult.of(list);
}
```



## 三十二、文件导出-支持加水印

### 32.1说明
- 文件加水印工具类可以为xls, xlsx, docx，et文档添加水印。

- 水印文本可以为多个；

- 支持设置水印的颜色、旋转角度；



### 32.2使用方法

#### 32.2.1. 添加maven依赖（必须）：
```xml
<dependency>
  <groupId>com.ygsoft.jt.teng</groupId>
  <artifactId>teng.cp.file.export</artifactId>
  <version>8.2.0.SP</version>
</dependency>
```



#### 32.2.2. 构造通用水印（必须）：

```java
GeneralWatermarkInterface generalWatermark = new GeneralWatermark(Arrays.asList("保密", "xcptb", "abc"));
```



#### 32.2.3. 设置水印颜色(可选，默认灰色)：

``` java
// 使用十六进制颜色字符串
// 绿色，格式：#RRGGBBAA， R:红色强度，G:绿色强度，B:蓝色强度，A:透明度
generalWatermark.setWatermarkColor("#00FF00FF"); 
// 或者使用Color常量
generalWatermark.setWatermarkColor(Color.ORANGE); // 橙色
```



#### 32.2.4. 设置水印旋转角度（可选，默认顺时针旋转45度）

```java
// 正为顺时针，负为逆时针，建议保持默认的45度
generalWatermark.setRotationAngle(-45.0);
```



#### 32.2.5. 使用通用水印为文档添加水印（必须）：

- 可以使用文档输入流：

```java
documentInputStream = WatermarkUtil.addWatermark(
documentInputStream, // 事先构造好的文档输入流
generalWatermark,  // 刚刚构造的通用水印
DocumentType.XLSX); // 文档类型，还可以选择：DocumentType.DOCX、DocumentType.XLS
```



- 文档也可以通过字节数组提供：

```java
documentInputStream = WatermarkUtil.addWatermark(
documentByteArray, // 事先构造好的文档字节数组
generalWatermark,  
DocumentType.XLSX); 
```

