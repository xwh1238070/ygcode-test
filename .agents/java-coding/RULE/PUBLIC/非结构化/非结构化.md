# 非结构化规范文档

## 概述
本文档旨在为使用非结构化提供详细的开发规范和指导。通过本指南，您将了解如何使用非结构化组件。


## 简介

非结构化数据，指信息的形式相对不固定的数据，常常是各种格式的文件，包括所有格式办公文档、文本、图片、XML、HTML、各类报表、图像和音频/视频信息等等。非结构化组件提供存储或监控如上非结构化数据的基础组件，通过适配，支持的存储方式有数据库、文件系统、sftp、hdfs、oss、cos、uds等等，系统默认将这些上传的文件存储在文件系统上。用户可根据部署环境，选择以下一种附件存储方式。不同的数据存储方式，需要引入不同的jar包，但应用层所使用的接口是一致的.

|  厂商 |  存储方式 |   artifactId| 说明  |
| ------------| ------------ | ------------ |
| —— |FILE	|teng.cp.unstructure.file| 文件存储 |
| —— |HDFS	|teng.cp.unstructure.hdfs| 适用于使用搭建了HDFS的环境。HDFS（Hadoop Distributed File System）是 Apache Hadoop 生态系统中的一部分，是一个分布式文件系统，旨在用于存储大规模数据集，并提供高吞吐量的数据访问 |
| —— |SFTP	|teng.cp.unstructure.sftp| ftp存储 |
| 亚马逊S3 |COS	|teng.cp.unstructure.cos| 适用于使用腾讯云COS，从腾讯云申请到COS帐号后，可从用户后台中找到接入点、KEY、密钥、Bucket等信息|
| 阿里云 |OSS	|teng.cp.unstructure.oss| 适用于使用阿里云的OSS，从阿里云申请到OSS帐号后，可从阿里用户后台中找到接入点、KEY、密钥、Bucket等信息。（注意：从公司访问阿里云，需申请开通网络权限） |
| 华为云 |OBS	|teng.cp.unstructure.obs| 华为云OBS |
| NW |ATM	|teng.cp.unstructure.atm| 仅用于NW的ATM环境，需向NW相关环境管理人员获取ATM的配置信息。 |
| GW |UDS	|teng.cp.unstructure.uds| 适用于使用GW的UDS |
| GW |UDS2	|teng.cp.unstructure.ext| 适用于使用GW的UDS2.0  |
| NW |UDSP   |teng.cp.unstructure.nwm| 用于接入NW中台的非结构化数据服务平台 |
| —— |Video  |teng.cp.unstructure.video| 为公司云服务封装的用于视频播放的组件 |



## 术语说明

### 1、文件摘要：

对文件资源的基础描述，包括附件的资源标识，名称、大小、类型、上传时间及关联的业务标识等基础信息等。对应VO对象  EntityAttachmentSummaryVO。对应数据表为T_SYS_ATTACHMENT_SUMMARY

|  名称 |   描述|
| ------------ | ------------ |
|  resId |  资源ID |
| ywkey  | 业务KEY  |
|  title |  附件名称 |
|  btype |  附件类型 |
| remark  | 备注  |
|  bsize |  附件大小 |
|  status |  附件状态 |
|  bsort |  排序 |
|  customproperty |  自定义属性 |



### 2、文件内容：

当我们进行实体转换的时候，如果旧的实体已关联的附件信息，那么新的实体无需再上传附件，只需增加对原有附件的引用即可，引用信息包括附件的资源id和附件的业务关联引用标识，这样信息的描述就是附件的引用模型。对应VO对象  EntityAttachmentReferenceVO。对应数据表为T_SYS_ATTACHMENT_REFERENCE。

|  名称 |   描述|
| ------------ | ------------ |
|  id |  资源ID |
| length  | 附件大小  |
|  lastModified |  修改时间 |
|  externalId |  外部ID |
|  data |  附件内容 |



### 3、文件引用：

当我们进行实体转换的时候，如果旧的实体已关联的附件信息，那么新的实体无需再上传附件，只需增加对原有附件的引用即可，引用信息包括附件的资源id和附件的业务关联引用标识，这样信息的描述就是附件的引用模型。对应VO对象  EntityAttachmentReferenceVO。对应数据表为T_SYS_ATTACHMENT_REFERENCE。

|  名称 |   描述|
| ------------ | ------------ |
|  resId |  资源ID |
| refid  | 引用ID（关联的业务key）  |



## 非结构化扩展组件接入

### 1、maven依赖

#非结构化扩展组件，支持DB,FILE,SFTP,UDS2,COS,OSS,OBS,ATM存储方式

```xml
<dependency>
  <groupId>com.ygsoft.jt.teng</groupId>
  <artifactId>teng.cp.unstructure.ext</artifactId>
</dependency>
```

### 2、方法说明

| 方法名 | 方法说明 | 参数 | 参数说明 | 备注 |
| ------ | ------ | ------ | ------ | ------ |
| saveSummaryAndDetail(final EntityAttachmentSummaryVO attachmentSummaryVO) | 附件上传 | attachmentSummaryVO  | 附件摘要VO | 保存附件摘要、附件内容 |
| getSummaryAndDetailByResId(final String resId) | 根据资源id下载附件内容和摘要 |  resId | 资源id | 根据附件摘要id(资源id)取得附件摘要、附件内容对象 |
| deleteSummaryAndDetailByResId(final String resId) |  | resId | 资源id |  |
| getSummariesByYwkey(final String ywkey) | 根据资源id删除附件摘要和内容 | ywkey | 业务key |根据附件摘要id(资源id)删除附件摘要，并且删除附件内容 |
| getSummariesAndDetailsByYwkey(final String ywkey) | 根据业务id下载正式状态的附件摘要和内容 | ywkey | 业务key  | 据业务id取得正式状态的附件摘要信息、附件内容列表 |
| getAllSummariesAndDetailsByYwkey(final String ywkey) |根据业务id下载所有状态的附件摘要和内容  | ywkey | 业务key  | 根据业务id取得所有状态的附件摘要信息、附件内容列表 |
| getSummariesByYwkeys(final List<String> ywkeys) | 根据业务key批量下载附件摘要信息 | ywkeys | 业务keys  | 根据多个业务key取得附件摘要信息列表 |
| getDetailByResId(final String resId) | 根据资源id附件下载附件内容 | resId | 资源id  | 根据附件摘要id(资源id)取得附件内容对象 |
| getSummaryByResId(final String resId) |根据资源id附件下载附件摘要 | resId | 资源id   | 根据附件摘要id(资源id)取得附件摘要对象 |
| updateSummaryFormalStatusByYwkeyOrResId(final String ywkeyOrResId) | 根据ywkey或者resId修改附件摘要状态为正式状态 | ywkeyOrResId | 业务key或者resId  |  |
| updateSummariesBySummaries(final List<EntityAttachmentSummaryVO> summaries) | 根据附件摘要集合操作附件摘要:把删除状态的附件物理删除、把临时新增的更新为正式新增 | summaries | 附件摘要集合(required:resId/status/ywkey)  |  |
| updateSummaryYwkeyByResId(final String resId, final String ywkey) | 根据资源id修改附件摘要ywkey | resId,ywkey |资源id,业务key  | |
| addDetailWithInputStream(final InputStream data) | 用数据流新增附件附件内容，并产生附件摘要对象信息 | data | 附件内容数据流 | 这个方法会新增临时附件，业务逻辑还需调用updateSummaryFormalStatusByYwkeyOrResId把状态改为正式的 |
| getDetailDataByResId(final String resId) | 根据资源id下载附件内容的数据流 | resId | 资源id | 根据附件摘要id(资源id)取得附件内容对象的数据流 |
| deleteSummariesAndDetailsByYwkey(final String ywkey) | 根据业务id删除附件摘要，并且删除附件内容 | ywkey | 业务key |  |
| saveSummaryAndDetailTemp(final EntityAttachmentSummaryVO attachmentSummaryVO) | 附件上传（临时） | attachmentSummaryVO | 附件摘要VO | 保存附件摘要、附件内容，这个方法会把摘要状态设置为临时状态 |
| saveSummariesAndDetails(final List<EntityAttachmentSummaryVO> attachmentSummaryVOs) | 附件上传（批量） | attachmentSummaryVOs | 附件摘要VOs | 批量保存附件摘要、附件内容 |
| getDetailsByYwkeys(final List<String> ywkeys) | 根据业务key批量下载附件 | ywkeys |业务keys  |  |
| dispatchFile(final String storageSourceId, final String resId, final String systemCode, final String deployCode) | 分发文件 | storageSourceId，resId，systemCode，deployCode |  存储源标识，附件标识，系统编码 ，部署点编码| |
| uploadMockPlus(final String ywKey, final String fileName, final String fileType,final String storageSourceId, MultipartFile file) | 指定业务单号上传附件(模拟plus上传失败) | ywKey，fileName，fileType，storageSourceId，file| 业务单号，文件名，文件类型，存储源标识，文件| |
| mockFixByResId(final String resId) | 模拟plus上传失败后修复 | resId| 资源id| |
| uploadMockObsDir(final String ywKey, final String fileName, final String fileType,final String storageSourceId, MultipartFile file) | OBS文件存储调整为按目录存储 |  ywKey，fileName，fileType，storageSourceId，file|业务单号，文件名，文件类型，存储源标识，文件|目录结构：年_月_日/文件id + 文件名称 + 文件类型 |
| addBizRelationData(final String storageSourceId) | 新增文件关系业务信息(模拟uds2). |  storageSourceId |存储源标识 |
| updateBizRelationData(final String storageSourceId) | 修改文件关系业务信息(模拟uds2).. |  storageSourceId |存储源标识 |
|  channelUpload(final String fileName, final String storageSourceId, final String fileType, final MultipartFile file)| 平台提供文件传输通道方法，文件存储信息不存储到summary表-上传 |  storageSourceId |文件名称，存储源标识，文件类型，文件 |
| channelDownload(final String storageSourceId, final String storageAddress, final HttpServletResponse response)| 平台提供文件传输通道方法，文件存储信息不存储到summary表-下载 |  storageSourceId |存储源标识，附件存储地址 |
|uploadNonTx(final String ywKey, final String fileName, final String fileType, final String storageSourceId, final int timeout, MultipartFile file)| 非事务上传附件,获取UDS文件的日志 增加存储源名称打印 |   ywKey，fileName，fileType，storageSourceId，file，timeout|业务单号，文件名，文件类型，存储源标识，文件 ，超时时间,单位毫秒|
|downloadNonTx(final String storageSourceId, final String resId, final int timeout, final HttpServletResponse response)| 非事务下载附件,获取UDS文件的日志 增加存储源名称打印 | storageSourceId， resId，timeout|存储源标识，资源id，超时时间,单位毫秒|
|uploadNonTx(final String ywKey, final String fileName, final String fileType, final String storageSourceId, final int timeout, MultipartFile file)| sftp配置，支持uds2流式上传 | storageSourceId， resId，timeout|存储源标识，资源id，超时时间,单位毫秒|



### 3、方法说明（非事务，操作和存表不在同一事务）

| 方法名 | 方法说明 | 参数 | 参数说明 | 备注 |
| ------ | ------ | ------ | ------ | ------ |
| addSummaryAndDetail(EntityAttachmentSummaryVO summary) | 非事务附件上传 | summary | 包含要添加的摘要和内容信息 | 先内容再摘要,内容添加成功才添加摘要 |
| getSummaryAndDetailByResId(String resId) | 非事务附件下载 | resId | 资源id | 根据资源ID获取摘要和内容 |
| getSummaryAndDetailByResId(String resId, int timeoutMill) | 非事务附件下载，有超时时间  | resId，timeoutMill |资源id，超时时间（毫秒） | 根据资源ID获取摘要和内容,有超时时间 |
| getDetailBySummary(EntityAttachmentSummaryVO summary) | 非事务附件下载，根据附件摘要获取附件内容 | summary | 附件摘要 | 附件内容,内容通过属性inputStream传递 |
| getDetailBySummary(EntityAttachmentSummaryVO summary, int timeoutMill) | 非事务附件下载，根据附件摘要获取附件内容,有超时时间 | summary，timeoutMill | 附件摘要，超时时间（毫秒） | 附件内容,内容通过属性inputStream传递 |



### 4、方法说明（配置多存储源）

| 方法名 | 方法说明 | 参数 | 参数说明 | 备注 |
| ------ | ------ | ------ | ------ | ------ |
| getUnstructureStorage(final String storageSource) | 通过存储源标识获取非结构化存储实例 | storageSource | 存储源标识 |  |
| getUnstructureStorageByResId(final String resId) | 通过资源id获取非结构化存储实例 | resId | 资源id |  |
| getNonTxStorageSource(final String storageSource) | 通过存储源标识获取非事务的存储源 | storageSource | 存储源标识 |  |
| buildNonTxStorageSource(final IEntityAttachmentContext ctx) | 根据存储源实例构建非事务存储源 | ctx | 存储源实例 |  |
| buildNonTxStorageSource(final ExtendedUnstructureStorage eus) | 根据非结构化存储实例构建非事务存储源 | eus | 非结构化存储实例 |  |
| getDefaultStorageSource() | 获取默认存储源 |  |  |  |
| getStorageSource(final String storageSource) | 通过存储源标识获取存储源 | storageSource | 存储源标识 |  |
| parseStorageSource(final EntityAttachmentSummaryVO vo) | 解析出存储源标识 | vo | 包含附件摘要信息 |  |
| createAttachmentContext(final String storageSource,final String storageSourceType) | 创建存储源 | storageSource，storageSourceType | 存储源标识，存储源类型 |  |
| getUds2StorageSource(final IEntityAttachmentContext ctx, final String storageSource) |获取适配uds2.0的存储源  | ctx，storageSource | 已有存储源，存储源标识,包含sc和dc | 复用已有存储源基本属性,存储源标识必须包含sc和dc |



### 5、restful接口

#### （1）上传接口

- 请求方式：POST

- 请求地址：/inner/{vipaddress}/jt/us/save

- 输入参数：RestEntityAttachmentSummaryVO对象

| 参数名称 |  描述  |   备注   |
| ------------ | ------------  | ------------ |
| setAddtime  |  创建时间  ||
| setDetail  | 附件内容对象RestEntityAttachmentDetailVO  |setFileBytes（附件内容）、setLength（附件大小，100M以内）|
| setBsize  | 附件大小  ||
| setYwkey  | 业务id  ||
| setTitle  | 文件名称  ||
| setBtype  | 文件类型，未限制  ||
| setResId  | 资源id ||



- 调用样例：


```java
	/**
	 * 指定业务单号上传附件(转调restful接口).
	 *
	 * @param ywKey
	 *            业务单号
	 * @param fileName
	 *            文件名
	 * @param fileType
	 *            文件类型
	 * @param file
	 *            文件
	 * @param request 请求
	 * @return 上传操作的结果信息
	 * @ReviewInfo(reviewer = "zengxianhua", date = "2025-05-16")
	 */
	@EcpPostMapping("/upload/restful")
	public String upload2Restful(final String ywKey, final String fileName, final String fileType, final MultipartFile file,final HttpServletRequest request) {
		String result = "上传失败";

		InputStream is = null;
		try {
			is = file.getInputStream();
			final byte[] fileData = IOUtils.toByteArray(is);
			final RestEntityAttachmentDetailVO detail = new RestEntityAttachmentDetailVO();
			detail.setFileBytes(fileData);
			detail.setLength((long) fileData.length);


			final String resId = UUID.randomUUID().toString();
			RestEntityAttachmentSummaryVO summary = new RestEntityAttachmentSummaryVO();
			summary.setAddtime(new Date());
			summary.setDetail(detail);
			summary.setBsize(file.getSize());
			summary.setYwkey(ywKey);
			summary.setTitle(fileName);
			summary.setBtype(fileType);
			summary.setResId(resId);

			final Map<String, String> headerMap = new HashMap<String, String>();
			final String tenantId = SessionUtil.getTenantId(request);
			headerMap.put("orgCode", tenantId);
			String url = "/inner/jt/mapp/sample/jt/us/save";
			final CommonResult<?> restfulResult = MappService.INSTANCE.doPost(url, headerMap, summary, CommonResult.class, new Object[]{});
			result = (String) restfulResult.getData();
		} catch (IOException e) {
			if (LOG.isInfoEnabled()) {
				LOG.info("从文件获取内容时出错", e);
			}
		} finally {
			if (null != is) {
				try {
					is.close();
				} catch (IOException e) {
					if (LOG.isErrorEnabled()) {
						LOG.error("关闭文件流时出错", e);
					}
				}
			}
		}

		return result;
	}

```



- 输出参数：

| 参数名称 |  描述  |   备注   |
| ------------ | ------------  | ------------ |
| resid  |  资源ID  |   |



#### 2）下载接口

- 请求方式：GET

- 请求地址：/inner/{vipaddress}/jt/us/get?resId={resId}

- 输入参数：

| 参数名称 |  描述  |   备注   |
| ------------ | ------------  | ------------ |
| resId  |  资源ID | |



- 调用样例：

```java
/**
	 * 按附件标识下载附件(转调restful接口).
	 *
	 * @param resId
	 *            附件标识
	 * @param request 请求
	 * @param response
	 *            下载附件的响应
	 * @return 下载操作的结果信息
	 * @ReviewInfo(reviewer = "zengxianhua", date = "2025-05-16")
	 */
	@EcpGetMapping("download/restful")
	public String download2restful(final String resId, final HttpServletRequest request, final HttpServletResponse response) {
		String result = "下载失败";

		final String url = "/inner/jt/mapp/sample/jt/us/get?resId=" + resId;
		final Map<String, String> headers = new HashMap<String, String>();
		final String tenantId = SessionUtil.getTenantId(request);
		headers.put("orgCode", tenantId);

		final CommonResult<?> restfulResult = MappService.INSTANCE.doGet(url, headers, CommonResult.class, new Object[]{});
		final JSONObject data = (JSONObject) restfulResult.getData();
		final RestEntityAttachmentDetailVO detail = JSON.toJavaObject(data.getJSONObject("attachmentDetailVO"), RestEntityAttachmentDetailVO.class);
		final EntityAttachmentSummaryVO summary = JSON.toJavaObject(data, EntityAttachmentSummaryVO.class);
		final Blob blob = BlobUtils.bytes2Blob(detail.getFileBytes());

		response.setHeader("content-type", "application/octet-stream");
		response.setContentType("application/octet-stream");

		final String value = String.format("attachment;filename=%s", getFileName(summary));
		response.setHeader("content-disposition", value);

		try (
				BufferedInputStream is = new BufferedInputStream(blob.getBinaryStream());
				OutputStream out = response.getOutputStream();
		) {
			byte[] datas = new byte[is.available()];
			is.read(datas, 0, datas.length);

			out.write(datas);
			out.flush();

			result = "下载成功";
		} catch (Exception e) {
			if (LOG.isErrorEnabled()) {
				LOG.error(e.toString());
			}
		}

		return result;
	}
}

```



- 输出参数：

| 参数名称 |  描述  |   备注   |
| ------------ | ------------  | ------------ |
| CommonResult  |  附件内容对象EntityAttachmentSummaryVO  |   |



## 非结构化nw组件接入

### 1、maven依赖

```xml
#非结构化nw组件，只用于接入nw中台的非结构化数据服务平台
<dependency>
  <groupId>com.ygsoft.jt.teng</groupId>
  <artifactId>teng.cp.unstructure.nwm</artifactId>
</dependency>
```

### 2、方法说明

| 方法名 | 方法说明 | 参数 | 参数说明 | 备注 |
| -------- |  -------- |  -------- |  -------- |  -------- |
| saveSummaryAndDetail(EntityAttachmentSummaryVO attachmentSummaryVO) | 附件上传  |attachmentSummaryVO  | 附件摘要VO  | 保存附件摘要、附件内容，这个方法会把摘要状态设置为正式状态  |
| getSummaryAndDetailByResId(String resId) | 根据资源id下载附件内容和摘要  | resId  | 资源id  | 根据附件资源id取得附件摘要、附件内容 |
| deleteSummaryAndDetailByResId(String resId) | 根据资源id删除附件摘要和内容  | resId  | 资源id  | 根据附件资源id删除附件摘要，并且删除附件内容  |
| getSummariesByYwkey(String ywkey)| 根据业务id下载正式状态的附件摘要 | ywkey | 业务key | 根据业务id取得正式状态的附件摘要信息 |
|getSummariesAndDetailsByYwkey(String ywkey)| 根据业务id下载正式状态的附件摘要和内容 | resId | 资源ID  |根据业务id取得正式状态的附件摘要信息、附件内容 |
|getAllSummariesAndDetailsByYwkey(String ywkey)| 根据业务id下载所有状态的附件摘要和内容 | ywkey | 业务key  |根据业务id取得所有状态的附件摘要信息、附件内容 |
| getSummariesByYwkeys(List<String> ywkeys)| 根据业务key批量下载附件摘要信息 | ywkeys | 业务keys  |根据多个业务key取得附件摘要信息 |
| getDetailsByYwkeys(List<String> ywkeys) |根据业务key批量下载附件明细 | ywkeys | 业务keys | 根据多个业务key取得附件明细列表 |
| getDetailByResId(String resId) | 根据资源id下载附件内容  | resId  | 资源id  |   |
| getSummaryByResId(String resId) | 根据资源id下载附件摘要  | resId  | 资源id  |   |
|updateSummaryFormalStatusByYwkeyOrResId(String ywkeyOrResId)  |  根据ywkey或者resId修改附件摘要状态为正式状态 | ywkeyOrResId  | 业务key或者resId  |   |
| updateSummariesBySummaries(List<EntityAttachmentSummaryVO> summaries) | 根据附件摘要集合操作附件摘要:把删除状态的附件物理删除、把临时新增的更新为正式新增  | summaries  | 附件摘要集合(required:resId/status/ywkey)  |   |
| updateSummaryYwkeyByResId(String resId, String ywkey) | 根据resId修改附件摘要ywkey  | resId，ywkey  | 资源id，业务key |   |
| addDetailWithInputStream(InputStream data) | 用数据流新增附件内容，并产生附件摘要对象信息  | data  | 附件内容数据流  | 这个方法会新增临时附件，业务逻辑还需调用updateSummaryFormalStatusByYwkeyOrResId把状态改为正式的  |
| getDetailDataByResId(String resId) | 根据附件资源id获取附件内容对象的数据流  |  resId | 资源id  |   |
| deleteSummariesAndDetailsByYwkey(String ywkey) | 根据业务id删除附件摘要，并且删除附件内容  | ywkey  | 业务key  |   |
| saveSummaryAndDetailTemp(EntityAttachmentSummaryVO attachmentSummaryVO) | 附件上传（临时） | attachmentSummaryVO  | 附件摘要VO  | 保存附件摘要、附件内容，这个方法会把摘要状态设置为临时状态   |
| saveSummariesAndDetails(List<EntityAttachmentSummaryVO> attachmentSummaryVOs) | 附件上传（批量）  | attachmentSummaryVOs  | 附件摘要VOS  | 批量保存附件摘要、附件内容，状态设置为正式状态  |



### 3、方法说明（配置多个目标账号）

| 方法名 | 方法说明 | 参数 | 参数说明 | 备注 |
| -------- |  -------- |  -------- |  -------- |  -------- |
| getUnstructureStorage(final String targetDatasourceCode) | 通过目标账号获取非结构化存储实例  |targetDatasourceCode  | 目标账号  |  |
| getUnstructureStorageByResId(final String resId) | 通过资源id获取非结构化存储实例  | resId  | 资源id  | 非结构化存储实例,如果资源标识为空或不存在则返回null  |
| getDefaultStorageSource() | 获取默认存储源  |   |   |   |
| parseTargetDatasourceCode(final EntityAttachmentSummaryVO vo) | 解析目标账号  | vo  | 附件摘要VO  |   |
| getStorageSource(final String targetDatasourceCode) | 获取存储源  | targetDatasourceCode  | 目标账号  |   |
| createAttachmentContext(final String targetDatasourceCode) | 创建存储源  | targetDatasourceCode  | 目标账号  |   |



## 非结构化UDS组件接入

### 1、maven依赖

```xml
#非结构化UDS组件，支持UDS1.0的存储方式
<dependency>
  <groupId>com.ygsoft.jt.teng</groupId>
  <artifactId>teng.cp.unstructure.uds</artifactId>
</dependency>
```


## 非结构化视频组件接入

### 1、maven依赖

```xml
#非结构化视频组件，存储方式同非结构化扩展组件
<dependency>
  <groupId>com.ygsoft.jt.teng</groupId>
  <artifactId>teng.cp.unstructure.video</artifactId>
</dependency>
```


### 2、方法说明

| 方法名 | 方法说明 | 参数 | 参数说明 |  备注 |
| -------- |  -------- |  -------- |  -------- |  -------- |
| saveVideo(EntityAttachmentSummaryVO attachmentSummaryVO) | 保存视频,同时生成视频封面并保存  | attachmentSummaryVO  | 视频内容  |暂时只支持mp4文件，保存时会返回视频的资源id【resId】，并随机截取视频某一帧作为封面保存，封面文件的资源id为resId_0  |
| playByResId(final String resId, final HttpServletRequest request, final HttpServletResponse response) |  播放由资源id指定的视频 | resId，request，response  | 资源id，http请求，http响应  |   |    |
| deleteVideo(String resId) | 删除视频,同时删除视频封面  | resId  | 视频的资源id  |   |
| generateCover(String resId) | 现有视频生成封面并保存  | resId  | 视频的资源id  |   |
| generateCoverFile(final EntityAttachmentDetailVO detail) |  生成封面文件 | detail  | 包含视频数据  |   |
| saveConver(EntityAttachmentSummaryVO videoVO, File coverFile) | 保存封面到非结构化存储源  | videoVO，coverFile | 包含视频信息，视频封面文件  |   |
| playByStorageSourceAndResId(final String storageSource, final String resId, final HttpServletRequest request, final HttpServletResponse response) |  播放由存储源和资源id指定的视频 |  storageSource，resId，request，response  |存储源，资源id，http请求，http响应 |   |
|playWithDownload(final String storageSource, final String resId, final HttpServletRequest request,final HttpServletResponse response) | 下载整个视频,响应前端播放  | storageSource，resId，request，response  |存储源，资源id，http请求，http响应  |   |
|playWithRange0(final String storageSource, final String resId, final HttpServletRequest request, final HttpServletResponse response)  | 响应前端发送Range为0- 的范围,为播放提供视频流  |  storageSource，resId，request，response  |存储源，资源id，http请求，http响应 |   |
| playRange(final String storageSource, final String resId, long start, long end, final HttpServletRequest request, final HttpServletResponse response) | 获取视频某范围的数据,为前端播放提供视频流 |storageSource，resId，start，end，request，response  |存储源，资源id，范围的开始，范围的借宿，http请求，http响应 |   |
| doPlay(final StreamingMediaReader reader, final HttpServletRequest request,final HttpServletResponse response) | 执行播放,为前端提供视频流  | reader，request，response  | 流媒体阅读器实例，请求，响应  |   |



### 3、业务组扩展代码示例

```java
/*
 * Copyright (C) 2005 - 2030 YGSoft.Inc All Rights Reserved.
 * YGSoft.Inc PROPRIETARY/CONFIDENTIAL.Use is subject to license terms.
 */
package com.ygsoft.jt.mapp.sample.impl.component.unstructure.ext.av.controller;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.URLEncoder;
import java.sql.Blob;
import java.sql.SQLException;
import java.util.Date;
import java.util.UUID;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.io.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import com.ygsoft.ecp.service.tool.StringUtil;
import com.ygsoft.jt.mapp.sample.impl.cons.BusinessExceptionConst;
import com.ygsoft.jt.mapp.sample.impl.cons.OwnerConst;
import com.ygsoft.jt.mapp.sample.impl.exception.SampleBusinessException;
import com.ygsoft.jt.teng.cp.unstructure.av.UnstructureVideoSupportor;
import com.ygsoft.jt.teng.cp.unstructure.av.service.StreamingMediaService;
import com.ygsoft.jt.teng.cp.unstructure.core.context.IEntityAttachmentContext;
import com.ygsoft.jt.teng.fw.core.base.cons.RestErrorCodeEnum;
import com.ygsoft.jt.teng.fw.core.base.model.CommonResult;
import com.ygsoft.jt.teng.fw.core.base.util.JtI18nUtil;
import com.ygsoft.jt.teng.fw.core.log.IJtLog;
import com.ygsoft.jt.teng.fw.core.log.JtLogFactory;
import com.ygsoft.jt.teng.fw.core.log.LogContextHolder;
import com.ygsoft.jt.teng.fw.core.service.JtService;
import com.ygsoft.jt.teng.fw.core.service.model.unstructure.EntityAttachmentDetailVO;
import com.ygsoft.jt.teng.fw.core.service.model.unstructure.EntityAttachmentSummaryVO;
import com.ygsoft.jt.teng.fw.core.service.storage.IUnstructureStorage;
import com.ygsoft.jt.teng.fw.core.service.tool.BlobUtils;
import com.ygsoft.jt.teng.fw.core.service.tool.DateUtil;
import com.ygsoft.jt.teng.fw.core.service.tool.FileUtil;
/**
 * 非结构化支持视频播放样例接口类.
 * 
 * @date 2023年5月22日 下午3:34:29
 * @version 1.0.0 JDK1.8
 */
@RestController
@RequestMapping(OwnerConst.REST_API_PREFIX + "/unstructure/av")
public class UnstructureAvController {
    /**
     * 日志.
     */
    private static final IJtLog LOG = JtLogFactory.getLog(UnstructureAvController.class);
    /**
     * UPLOAD_PATH.
     */
    private static final String UPLOAD_PATH = "upload";
    /**
     * 附件摘要和内容场景接口.作为UnstructureVideoSupportor构造的参数传入.
     */
    @Autowired
    @Qualifier("jtEntityAttachmentContext")
    private IEntityAttachmentContext service;
    /**
     * 视频播放类，提供播放视频操作.
     */
    @Autowired
    private StreamingMediaService mediaService;
    /**
     * 非结构化存储实体，支持文件上传，下载，删除等操作.
     */
    @Autowired
    private IUnstructureStorage storageService;
    /**
     * 视频支持类，提供视频文件上传，删除功能.
     */
    private UnstructureVideoSupportor videoSupportor = null;
    /**
     * 获取UnstructureVideoSupportor.<br>
     * 提供视频文件上传，删除的功能
     * @return UnstructureVideoSupportor
     */
    private UnstructureVideoSupportor getVideoSupportor() {
        if (this.videoSupportor == null) {
            this.videoSupportor = new UnstructureVideoSupportor(service);
        }
        return this.videoSupportor;
    }
    /**
     * 上传视频文件.超过100M需要分片上传.<br>
     * 分片上传时，需要额外传入resId, fileName, size, chunks【分片总数】, chunk【本次上传分片，从0开始】<br>
     * 当chunk = chunks-1 时，表示上传完毕.
     * @param file
     * @param ywKey
     * @return CommonResult<String>
     */
    @PostMapping("/upload")
    public CommonResult<String> uploadVideoFile(final MultipartFile file, final String ywKey, String resId,
            final HttpServletRequest request) {
        // 不是分片上传时，直接生成resId.
        if (StringUtil.isEmpty(resId)) {
            resId = UUID.randomUUID().toString();
        }
        // 不是分片上传时，直接读取文件大小.
        String parameterSize = request.getParameter("size");
        Long fileSize = 0L;
        if (StringUtil.isEmpty(parameterSize)) {
            fileSize = file.getSize();
        } else {
            fileSize = Long.parseLong(parameterSize);
        }
        // 不是分片上传时，直接读取文件名称.
        String fileName = request.getParameter("fileName");
        if (StringUtil.isEmpty(fileName)) {
            fileName = file.getOriginalFilename();
        }
        int dotIndex = fileName.lastIndexOf(".");
        // 文件名
        String realName = "";
        // 后缀
        String ext = "";
        if (dotIndex < 0) {
            realName = fileName;
            ext = "";
        } else {
            realName = fileName.substring(0, dotIndex);
            ext = fileName.substring(dotIndex + 1).toLowerCase();
        }
        // 暂时只能上传mp4视频
        if (!"mp4".equals(ext)) {
            return CommonResult.of("上传失败.", RestErrorCodeEnum.UNKNOWN_EXCEPTION.getErrorCode4Area1(), "文件后缀格式不支持.");
        }
        // 把数据流转换成Blob对象，用于直接存放到数据库
        Blob dataBlob = null;
        // 生成UUID
        if (request.getParameter("chunks") == null) {
            try {
                dataBlob = BlobUtils.bytes2Blob(IOUtils.toByteArray(file.getInputStream()));
            } catch (IOException e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(e.toString());
                }
            }
        } else {
            // doSingleFileUpload
            dataBlob = doSingleFileUpload(file, request, fileSize, resId, realName, dataBlob);
        }
        if (dataBlob != null) {
            // 保存视频
            try {
                final long acturlFileLength = dataBlob.length();
                // 设置最大只能上传1G。暂时不在组件做限制，保留扩展性
                final long maxSize = 1024 * 1024 * 1024;
                if (acturlFileLength > maxSize) {
                    return CommonResult.of("上传失败.", RestErrorCodeEnum.UNKNOWN_EXCEPTION.getErrorCode4Area1(), "文件大小超过1G.");
                }
                final EntityAttachmentDetailVO detail = new EntityAttachmentDetailVO();
                detail.setData(dataBlob);
                detail.setLength(dataBlob.length());
                final String originalFilename = fileName;
                final String filename = fileName.substring(0, originalFilename.lastIndexOf("."));
                final String fileType = originalFilename.substring(originalFilename.lastIndexOf(".") + 1);
                final EntityAttachmentSummaryVO summary = new EntityAttachmentSummaryVO();
                summary.setAddtime(new Date());
                summary.setAttachmentDetailVO(detail);
                summary.setBsize(fileSize);
                summary.setYwkey(ywKey);
                summary.setTitle(filename);
                summary.setBtype(fileType);
                summary.setResId(resId);
                summary.setCustomProperty(file.getContentType());
                // 保存视频，并生成封面，封面文件id为视频id_0
                UnstructureVideoSupportor videoSupportor = getVideoSupportor();
                String saveVideo = videoSupportor.saveVideo(summary);
                // TODO:保存前可以做转码，压缩等操作
                return CommonResult.of(saveVideo);
            } catch (SQLException e) {
                LOG.error("上传失败，不支持的数据类型", e);
                throw new SampleBusinessException(BusinessExceptionConst.EX_BUSINESS_SQL_ERROR,
                        JtI18nUtil.localizedString(BusinessExceptionConst.EX_BUSINESS_SQL_ERROR, "上传失败，不支持的数据类型"));
            }
        } else {
            return CommonResult.of("分片保存成功：" + resId);
        }
    }
    /**
     * doSingleFileUpload.
     *
     * @param file
     *            file
     * @param request
     *            request
     * @param fileSize
     *            fileSize
     * @param resId
     *            resId
     * @param realName
     *            realName
     * @param dataBlob
     *            dataBlob
     * @return Blob
     */
    private Blob doSingleFileUpload(final MultipartFile file, final HttpServletRequest request, final Long fileSize,
            final String resId, final String realName, final Blob dataBlob) {
        // 分片上传处理
        final String realPath = JtService.getConfigService().getApplicationConfig().getAbsoluteStoragePath();
        if (LOG.isInfoEnabled()) {
            LOG.info("上传：realPath:" + realPath);
        }
        final int chunk = Integer.parseInt(request.getParameter("chunk")); // 当前分片
        final int chunks = Integer.parseInt(request.getParameter("chunks")); // 分片总计
        // 获取登录信息与当前日期标识当前文件
        String loginOrgName = "";
        if (LogContextHolder.INSTANCE.getLoginOrgName() == null) {
            loginOrgName = "";
        } else {
            loginOrgName = LogContextHolder.INSTANCE.getLoginOrgName();
        }
        final String userStr = loginOrgName + "###" + LogContextHolder.INSTANCE.getUserId() + "###" + realName + "###"
                + fileSize;
        final String curDateStr = DateUtil.shortDate2Str(DateUtil.getCurrentSystemTime());
        // 临时目录用来存储所有分片文件(app存储路径/上传根路径/用户文件标识)
        final String tempFileDirStr = realPath + File.separator + UPLOAD_PATH + File.separator + userStr
                + File.separator;
        if (LOG.isInfoEnabled()) {
            LOG.info("上传：tempFileDirStr:" + tempFileDirStr);
        }
        final File parentFileDir = new File(tempFileDirStr);
        boolean isFirstPart = false; // 是否第一次创建分片，判断依据为分片目录不存在
        if (!parentFileDir.exists()) {
            parentFileDir.mkdirs();
            isFirstPart = true;
        }
        final String tempPartName = resId + "_" + chunk + ".part";
        final File tempPartFile = new File(parentFileDir, curDateStr + "_" + tempPartName);
        if (LOG.isInfoEnabled()) {
            LOG.info("上传：tempPartName:" + tempPartName);
        }
        if (!isFirstPart) {
            final String[] existedFileNames = parentFileDir.list();
            for (String existedFileName : existedFileNames) {
                if (existedFileName.endsWith(tempPartName)) {
                    final File existedFile = new File(parentFileDir, existedFileName);
                    // 如果存在旧的文件
                    existedFile.renameTo(tempPartFile);
                    break;
                }
            }
        }
        // 分片处理时，前台会多次调用上传接口，每次都会上传文件的一部分到后台
        if (isFirstPart || !tempPartFile.exists()) {
            try {
                file.transferTo(tempPartFile);
            } catch (IOException e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(e.toString());
                }
            }
        }
        // 判断分片是否全部上传完成
        boolean uploadDone = true;
        for (int index = 0; index < chunks; index++) {
            final File partFile = new File(parentFileDir, curDateStr + "_" + resId + "_" + index + ".part");
            if (!partFile.exists()) {
                uploadDone = false;
            }
        }
        Blob retBlob = dataBlob;
        // 所有文件都上传完成
        if (uploadDone) {
            // 收集字节数组并转为blob
            retBlob = transBlob(fileSize, resId, dataBlob, chunks, curDateStr, tempFileDirStr);
        }
        return retBlob;
    }
    /**
     * 收集字节数组并转为blob.
     *
     * @param fileSize
     *            fileSize
     * @param resId
     *            resId
     * @param dataBlob
     *            dataBlob
     * @param chunks
     *            chunks
     * @param curDateStr
     *            curDateStr
     * @param tempFileDirStr
     *            tempFileDirStr
     * @return Blob
     */
    private Blob transBlob(final Long fileSize, final String resId, final Blob dataBlob, final int chunks,
            final String curDateStr, final String tempFileDirStr) {
        final byte[] buf = new byte[fileSize.intValue()];
        FileInputStream inputStream = null;
        DataInputStream dis = null;
        int start = 0;
        Blob retBlob = dataBlob;
        try {
            for (int index = 0; index < chunks; index++) {
                inputStream = new FileInputStream(tempFileDirStr + curDateStr + "_" + resId + "_" + index + ".part");
                final int len = inputStream.available();
                dis = new DataInputStream(inputStream);
                dis.read(buf, start, len);
                start = start + len;
                dis.close();
                inputStream.close();
            }
            retBlob = BlobUtils.bytes2Blob(buf);
        } catch (IOException e) {
            if (LOG.isErrorEnabled()) {
                LOG.error(e.toString());
            }
        } finally {
            try {
                if (dis != null) {
                    dis.close();
                }
                if (inputStream != null) {
                    inputStream.close();
                }
                try {
                    FileUtil.deleteDir(tempFileDirStr); // 清除临时文件存储目录
                } catch (Exception ex) {
                    JtLogFactory.getLog(getClass()).error(ex.getMessage(), ex);
                    ex.printStackTrace();
                }
            } catch (Exception e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(e.toString());
                }
            }
        }
        return retBlob;
    }
    /**
     * 下载文件。
     * 
     * @param resId
     * @param response
     *            void
     */
    @GetMapping("/download")
    public void download(final String resId, final HttpServletResponse response) {
        try {
            this.downloadFile(resId, response);
        } catch (NullPointerException e) {
            if (LOG.isInfoEnabled()) {
                LOG.info("文件资源不存在.", e);
            }
            response.setStatus(HttpServletResponse.SC_ACCEPTED);
            response.setContentType("text/html; charset=UTF-8");
            PrintWriter writer;
            try {
                writer = response.getWriter();
                writer.print("文件资源不存在.");
            } catch (IOException e1) {
                if (LOG.isErrorEnabled()) {
                    LOG.error("未知异常.", e);
                }
            }
        } catch (Exception e) {
            if (LOG.isErrorEnabled()) {
                LOG.error("未知异常.", e);
            }
            response.setStatus(HttpServletResponse.SC_ACCEPTED);
            response.setContentType("text/html; charset=UTF-8");
            PrintWriter writer;
            try {
                writer = response.getWriter();
                writer.print("未知异常.");
            } catch (IOException e1) {
                if (LOG.isErrorEnabled()) {
                    LOG.error("未知异常.", e);
                }
            }
        }
    }
    /**
     * 获取文件并写到response.
     * 
     * @param resId
     * @param response
     *            void
     */
    private void downloadFile(final String resId, final HttpServletResponse response) {
        final EntityAttachmentSummaryVO summaryAndDetailVo = storageService.getSummaryAndDetailByResId(resId);
        final Blob fileData = summaryAndDetailVo.getAttachmentDetailVO().getData();
        final String filename = summaryAndDetailVo.getTitle();
        final String fileType = summaryAndDetailVo.getBtype();
        response.setHeader("content-type", "application/octet-stream");
        response.setContentType("application/octet-stream");
        BufferedInputStream is = null;
        OutputStream out = null;
        try {
            final String fName = URLEncoder.encode(filename + "." + fileType.toLowerCase(), "UTF-8");
            response.setHeader("content-disposition", "attachment;filename=" + fName);
            int length = 0;
            byte[] datas = null;
            if (fileData != null) {
                length = (int) fileData.length();
                datas = new byte[length];
                // 以流的形式下载文件。
                is = new BufferedInputStream(fileData.getBinaryStream());
            } else {
                final File detailFile = summaryAndDetailVo.getAttachmentDetailVO().getFile();
                length = (int) detailFile.length();
                datas = new byte[length];
                // 以文件的形式下载文件。
                is = new BufferedInputStream(new FileInputStream(detailFile));
            }
            is.read(datas, 0, length);
            out = response.getOutputStream();
            out.write(datas);
            out.flush();
            // edit by zengzhi 20210624 begin for 2003418
            // out.close();
            // is.close();
            // edit by zengzhi 20210624 end for 2003418
        } catch (Exception e) {
            if (LOG.isErrorEnabled()) {
                LOG.error(e.toString());
            }
        } finally {
            // edit by zengzhi 20210624 begin for 2003418
            try {
                if (out != null) {
                    out.close();
                }
                if (is != null) {
                    is.close();
                }
            } catch (Exception e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(e.toString());
                }
            }
            // edit by zengzhi 20210624 end for 2003418
        }
    }
    /**
     * 删除视频文件及封面.
     * 
     * @param resId
     *            视频文件资源id.
     * @return CommonResult<Object>
     */
    @PostMapping("/delete")
    public CommonResult<Object> deleteVideo(String resId) {
        UnstructureVideoSupportor videoSupportor = getVideoSupportor();
        videoSupportor.deleteVideo(resId);
        return CommonResult.of("删除成功.");
    }
    /**
     * 通过resId播放视频.
     * 
     * @param resId
     * @param request
     * @param response
     */
    @GetMapping("/playByResId")
    public void playByResId(final String resId, final HttpServletRequest request, final HttpServletResponse response) {
        mediaService.playByResId(resId, request, response);
    }
}
```

